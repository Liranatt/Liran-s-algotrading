The ML (Machine Learning) Strategy is designed to make trading decisions based on a predictive model. Hereâ€™s a breakdown of how it works:

Prediction Goal: The core of the strategy is a Logistic Regression model that predicts whether a stock's closing price will be higher than its opening price on a given day. This is a simple "up" or "down" prediction.

Feature Engineering: To make its prediction, the model doesn't just look at the price. It calculates a variety of technical indicators from the historical data of each stock. These are its "features" and include:

Returns: 1-day, 5-day, and 10-day price changes.

Moving Averages (SMA): The stock's price relative to its 5-day and 20-day simple moving averages.

Volume: The trading volume compared to its average.

Technical Indicators: RSI (Relative Strength Index), MACD (Moving Average Convergence Divergence), and Bollinger Bands.

Volatility: The standard deviation of daily returns.

Generating Signals:

Buy Signals: The strategy looks for stocks the model predicts will go up (prediction == 1) with a high probability (default is >60%). It will then rank these stocks by probability and buy the top ones until it either runs out of allocated capital or reaches its maximum number of allowed positions (default is 10).

Sell Signals: A position is sold for one of three reasons:

Take Profit: If the stock's price rises by a set percentage (default is 3%).

Stop Loss: If the stock's price falls by a set percentage (default is 2%).

ML Prediction: If the model has a low conviction that the stock will continue to rise.

Where to See the Strategy in the Code
I've added comments directly into the ml_bot_strategy.py file below. The most important sections to look at are generate_signals, _generate_buy_signals, and _generate_sell_signals.

Python

# strategies/ml_bot_strategy.py

import pandas as pd
import numpy as np
import yfinance as yf
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score, classification_report
import joblib
import os
import warnings

warnings.filterwarnings('ignore')


class MLStrategy:
    """
    # ==============================================================================
    # WHAT THE STRATEGY DOES:
    #
    # This strategy uses a Machine Learning model to predict whether a stock's closing
    # price will be higher than its opening price for the day.
    #
    # 1.  It calculates a set of technical indicators for each stock (see _calculate_features).
    # 2.  It feeds these indicators into a pre-trained Logistic Regression model.
    # 3.  Based on the model's prediction, it generates BUY or SELL signals.
    #
    # ==============================================================================
    """

    def __init__(self, params, logger):
        """
        Initialize the ML strategy with parameters and logger.
        """
        self.params = params
        self.logger = logger
        self.model = None
        self.scaler = None
        self.feature_columns = None
        # These parameters are pulled from your config.py file
        self.model_path = params.get('model_path', 'ml_trading_model.pkl')
        self.min_probability = params.get('min_probability', 0.6)
        self.max_positions = params.get('max_positions', 10)
        self.stop_loss_pct = params.get('stop_loss_pct', 0.02)
        self.take_profit_pct = params.get('take_profit_pct', 0.03)

        self.logger.info("ML Strategy initialized.")

        # Try to load existing model
        if os.path.exists(self.model_path):
            self._load_model()
        else:
            self.logger.warning(f"Model file {self.model_path} not found. Will need to train model first.")

    def _load_model(self):
        """Load the pre-trained ML model."""
        try:
            model_data = joblib.load(self.model_path)
            self.model = model_data['model']
            self.scaler = model_data['scaler']
            self.feature_columns = model_data['feature_columns']
            self.logger.info(f"ML model loaded successfully from {self.model_path}")
        except Exception as e:
            self.logger.error(f"Error loading model: {e}")
            self.model = None

    def generate_signals(self, market_data, portfolio_positions, available_capital):
        """
        # ==============================================================================
        # WHERE TO SEE THE STRATEGY IN ACTION (1/3):
        #
        # This is the main function called by the PortfolioManager during the backtest.
        # It orchestrates the generation of both sell and buy signals.
        # The logs produced here will show you the high-level decisions the strategy makes.
        # ==============================================================================
        """
        self.logger.info(f"Generating ML signals with available capital: ${available_capital:.2f}")
        signals = []

        if self.model is None:
            self.logger.warning("ML model not loaded. Cannot generate signals.")
            return signals

        # 1. Generate SELL signals first to free up capital
        sell_signals = self._generate_sell_signals(market_data, portfolio_positions)
        signals.extend(sell_signals)

        # 2. Generate BUY signals if we have capacity and capital
        if len(portfolio_positions) < self.max_positions and available_capital > 0:
            buy_signals = self._generate_buy_signals(market_data, available_capital, len(portfolio_positions))
            signals.extend(buy_signals)

        self.logger.info(
            f"Generated {len(signals)} total signals ({len([s for s in signals if s['action'] == 'BUY'])} BUY, {len([s for s in signals if s['action'] == 'SELL'])} SELL)")
        return signals

    def _generate_sell_signals(self, market_data, portfolio_positions):
        """
        # ==============================================================================
        # WHERE TO SEE THE STRATEGY IN ACTION (2/3): SELL LOGIC
        #
        # This function decides WHEN TO SELL a stock you already own.
        # It sells for one of three reasons:
        #   1. STOP LOSS: The price dropped too much (e.g., -2%).
        #   2. TAKE PROFIT: The price went up enough (e.g., +3%).
        #   3. ML PREDICTION: The model is no longer confident the stock will go up.
        #
        # Check the 'ml_bot.log' file in your backtest output folder to see these messages.
        # ==============================================================================
        """
        sell_signals = []

        for pos in portfolio_positions:
            symbol = pos['symbol']
            quantity = pos['quantity']
            buy_price = pos['buy_price']

            if symbol not in market_data['stocks'] or market_data['stocks'][symbol].empty:
                continue

            try:
                current_price = market_data['stocks'][symbol]['Close'].iloc[-1]
                return_pct = (current_price - buy_price) / buy_price

                # Stop loss
                if return_pct <= -self.stop_loss_pct:
                    self.logger.info(f"SELL signal (Stop Loss) for {symbol}: {return_pct:.2%}")
                    sell_signals.append({'action': 'SELL', 'symbol': symbol, 'qty': quantity})
                # Take profit
                elif return_pct >= self.take_profit_pct:
                    self.logger.info(f"SELL signal (Take Profit) for {symbol}: {return_pct:.2%}")
                    sell_signals.append({'action': 'SELL', 'symbol': symbol, 'qty': quantity})
                # Check ML prediction for exit
                else:
                    prediction, probability = self._predict_stock(market_data['stocks'][symbol])
                    if prediction is not None and prediction == 0 and probability < 0.4:
                        self.logger.info(f"SELL signal (ML Prediction) for {symbol}: Low probability {probability:.2%}")
                        sell_signals.append({'action': 'SELL', 'symbol': symbol, 'qty': quantity})

            except Exception as e:
                self.logger.error(f"Error generating sell signal for {symbol}: {e}")

        return sell_signals

    def _generate_buy_signals(self, market_data, available_capital, current_positions):
        """
        # ==============================================================================
        # WHERE TO SEE THE STRATEGY IN ACTION (3/3): BUY LOGIC
        #
        # This function decides WHAT TO BUY.
        # 1. It runs the ML model on all available stocks.
        # 2. It filters for stocks where the model predicts the price will go UP
        #    with a probability higher than the 'min_probability' threshold from your config.
        # 3. It sorts these candidates by their prediction probability (highest first).
        # 4. It buys the top-ranked stocks until it runs out of money or hits the
        #    'max_positions' limit.
        #
        # Check the 'ml_bot.log' file to see which stocks it decides to buy and why.
        # ==============================================================================
        """
        buy_signals = []
        stock_data = market_data['stocks']
        predictions = []

        # Get all available stocks and their ML predictions
        for symbol, hist in stock_data.items():
            if hist.empty or len(hist) < 50:
                continue
            try:
                prediction, probability = self._predict_stock(hist)
                if prediction == 1 and probability >= self.min_probability:
                    current_price = hist['Close'].iloc[-1]
                    predictions.append({'symbol': symbol, 'probability': probability, 'price': current_price})
            except Exception as e:
                self.logger.debug(f"Error predicting {symbol}: {e}")
                continue

        if not predictions:
            self.logger.info("No stocks meet ML criteria for buying.")
            return buy_signals

        # Sort by probability (highest first)
        predictions.sort(key=lambda x: x['probability'], reverse=True)
        max_new_positions = self.max_positions - current_positions

        if max_new_positions > 0:
            capital_per_position = available_capital / max_new_positions
            for pred in predictions[:max_new_positions]:
                symbol, price, probability = pred['symbol'], pred['price'], pred['probability']
                if capital_per_position > price:
                    quantity = int(capital_per_position // price)
                    if quantity > 0:
                        self.logger.info(
                            f"BUY signal for {quantity} shares of {symbol} at ${price:.2f} (prob: {probability:.2%})")
                        buy_signals.append({'action': 'BUY', 'symbol': symbol, 'qty': quantity})
        return buy_signals

    def _predict_stock(self, stock_hist):
        """Make ML prediction for a single stock."""
        try:
            # Calculate features
            featured_df = self._calculate_features(stock_hist)
            if featured_df is None: return None, None
            # Get latest features
            latest_features = featured_df[self.feature_columns].iloc[-1:].dropna()
            if len(latest_features) == 0: return None, None
            # Scale and predict
            scaled_features = self.scaler.transform(latest_features)
            prediction = self.model.predict(scaled_features)[0]
            probability = self.model.predict_proba(scaled_features)[0][1]
            return prediction, probability
        except Exception as e:
            self.logger.debug(f"Error in prediction: {e}")
            return None, None

    # ... (feature calculation and training methods remain the same)
